<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Manager - Multi-View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        body.dark-mode .toolbar {
            background: #2a2a2a;
            border-bottom-color: #404040;
        }

        body.dark-mode .view-switcher {
            background: #1a1a1a;
        }

        body.dark-mode .view-btn.active {
            background: #3a3a3a;
        }

        body.dark-mode .filter-btn,
        body.dark-mode .search-box,
        body.dark-mode .toggle-descriptions,
        body.dark-mode .link-mode-btn,
        body.dark-mode .filter-clear {
            background: #2a2a2a;
            border-color: #404040;
            color: #e0e0e0;
        }

        body.dark-mode .view-container {
            background: #2a2a2a;
        }

        body.dark-mode .task-row:hover {
            background: #3a3a3a;
        }

        body.dark-mode .kanban-column {
            background: #1a1a1a;
        }

        body.dark-mode .kanban-card {
            background: #2a2a2a;
            border-color: #404040;
        }

        body.dark-mode .gantt-header {
            background: #1a1a1a;
        }

        body.dark-mode .gantt-timeline {
            background: #1a1a1a;
        }

        body.dark-mode .mindmap-view {
            background: #1a1a1a;
        }

        body.dark-mode .mindmap-node {
            background: #2a2a2a;
            border-color: #404040;
        }

        body.dark-mode .detail-panel {
            background: #2a2a2a;
            border-left-color: #404040;
        }

        body.dark-mode .detail-input,
        body.dark-mode .detail-select {
            background: #1a1a1a;
            border-color: #404040;
            color: #e0e0e0;
        }

        body.dark-mode .modal-content {
            background: #2a2a2a;
        }

        body.dark-mode .add-task-btn {
            border-color: #404040;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .toolbar {
            background: white;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .view-switcher {
            display: flex;
            gap: 4px;
            background: #f0f0f0;
            padding: 4px;
            border-radius: 8px;
        }

        .view-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .view-btn:hover {
            background: #e0e0e0;
        }

        .view-btn.active {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .filters {
            display: flex;
            gap: 10px;
            align-items: center;
            flex: 1;
            flex-wrap: wrap;
        }

        .filter-group {
            display: flex;
            gap: 4px;
        }

        .filter-btn {
            padding: 6px 12px;
            border: 1px solid #d0d0d0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            border-color: #999;
        }

        .filter-btn.active {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }

        .search-box {
            padding: 6px 12px;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            font-size: 13px;
            width: 200px;
        }

        /* Settings Pane - View-Specific Settings */
        .settings-pane {
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
            padding: 10px 20px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            min-height: 48px;
        }

        body.dark-mode .settings-pane {
            background: #252525;
            border-bottom-color: #404040;
        }

        .settings-pane .setting-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .settings-pane .setting-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        body.dark-mode .settings-pane .setting-label {
            color: #999;
        }

        .settings-pane .setting-btn {
            padding: 6px 12px;
            border: 1px solid #d0d0d0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        body.dark-mode .settings-pane .setting-btn {
            background: #2a2a2a;
            border-color: #404040;
            color: #e0e0e0;
        }

        .settings-pane .setting-btn:hover {
            border-color: #999;
            background: #f5f5f5;
        }

        body.dark-mode .settings-pane .setting-btn:hover {
            background: #3a3a3a;
            border-color: #555;
        }

        .settings-pane .setting-btn.active {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }

        body.dark-mode .settings-pane .setting-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .settings-pane .setting-input {
            padding: 6px 12px;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            font-size: 13px;
            width: 200px;
            background: white;
        }

        body.dark-mode .settings-pane .setting-input {
            background: #2a2a2a;
            border-color: #404040;
            color: #e0e0e0;
        }

        .settings-pane .setting-select {
            padding: 6px 12px;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            font-size: 13px;
            background: white;
            cursor: pointer;
        }

        body.dark-mode .settings-pane .setting-select {
            background: #2a2a2a;
            border-color: #404040;
            color: #e0e0e0;
        }

        .settings-pane .divider {
            width: 1px;
            height: 24px;
            background: #d0d0d0;
            margin: 0 4px;
        }

        body.dark-mode .settings-pane .divider {
            background: #404040;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .view-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: white;
            margin: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        /* Outline View */
        .outline-view {
            font-size: 14px;
        }

        .task-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border-radius: 4px;
            margin: 2px 0;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }

        .task-row:hover {
            background: #f8f8f8;
        }

        .task-row.selected {
            background: #e0f2fe;
            outline: 2px solid #3b82f6;
        }

        .task-row.editing .task-title {
            background: white;
            border: 2px solid #3b82f6;
            padding: 4px 8px;
            border-radius: 4px;
            outline: none;
        }

        .task-title-editable {
            flex: 1;
            font-size: 14px;
            min-width: 100px;
            border: none;
            background: transparent;
            outline: none;
        }

        .task-title-editable:focus {
            background: white;
            border: 2px solid #3b82f6;
            padding: 4px 8px;
            border-radius: 4px;
            margin: -4px -8px;
        }

        .task-placeholder {
            color: #9ca3af;
            font-style: italic;
        }

        .inline-edit-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(59, 130, 246, 0.95);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            display: none;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .inline-edit-hint.visible {
            display: block;
        }

        .collapse-btn {
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 12px;
            width: 20px;
            padding: 0;
        }

        .status-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        .status-todo { background: #e5e7eb; color: #6b7280; }
        .status-in-progress { background: #dbeafe; color: #2563eb; }
        .status-review { background: #fef3c7; color: #d97706; }
        .status-done { background: #d1fae5; color: #10b981; }

        .task-title {
            flex: 1;
            font-size: 14px;
        }

        .task-description {
            color: #666;
            font-size: 13px;
            margin: 4px 0 8px;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            border-left: 3px solid #e0e0e0;
            cursor: text;
            min-height: 20px;
        }

        .task-description:focus {
            outline: 2px solid #3b82f6;
            background: white;
        }

        .task-description.task-placeholder {
            color: #9ca3af;
            font-style: italic;
        }

        .badge {
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .badge-high { background: #fee2e2; color: #dc2626; }
        .badge-medium { background: #fef3c7; color: #d97706; }
        .badge-low { background: #dbeafe; color: #2563eb; }
        .badge-todo { background: #e5e7eb; color: #6b7280; }
        .badge-in-progress { background: #dbeafe; color: #2563eb; }
        .badge-review { background: #fef3c7; color: #d97706; }

        .priority-indicator {
            font-size: 14px;
            margin-right: 4px;
        }
        .badge-done { background: #d1fae5; color: #10b981; }

        .assignee {
            padding: 2px 8px;
            background: #f3f4f6;
            border-radius: 12px;
            font-size: 11px;
            color: #4b5563;
        }

        .dependency-badge {
            padding: 2px 8px;
            background: #ede9fe;
            border-radius: 12px;
            font-size: 11px;
            color: #7c3aed;
            font-weight: 500;
        }

        /* Kanban View */
        .kanban-view {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            height: 100%;
        }

        .kanban-column {
            background: #f9fafb;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .kanban-header {
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .kanban-cards {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .kanban-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.2s;
        }

        .kanban-card:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .kanban-card.dragging {
            opacity: 0.5;
        }

        .kanban-card-title {
            font-weight: 500;
            margin-bottom: 8px;
        }

        .kanban-card-path {
            font-size: 11px;
            color: #9ca3af;
            margin-bottom: 8px;
            font-style: italic;
        }

        .kanban-card-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 8px;
            align-items: center;
        }

        /* Gantt View */
        .gantt-view {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .gantt-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e5e7eb;
        }

        .gantt-zoom-btn {
            padding: 6px 12px;
            border: 1px solid #d0d0d0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .gantt-zoom-btn:hover {
            border-color: #999;
        }

        .gantt-zoom-btn.active {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }

        .gantt-container {
            flex: 1;
            overflow: auto;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
        }

        .gantt-grid {
            display: grid;
            grid-template-columns: 250px 1fr;
            min-width: 100%;
        }

        .gantt-tasks {
            border-right: 1px solid #e5e7eb;
        }

        .gantt-header {
            position: sticky;
            top: 0;
            background: #f9fafb;
            border-bottom: 2px solid #e5e7eb;
            padding: 12px;
            font-weight: 600;
            z-index: 10;
        }

        .gantt-task-row {
            padding: 12px;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            transition: background 0.2s;
        }

        .gantt-task-row:hover {
            background: #f9fafb;
        }

        .gantt-task-title {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .gantt-task-dates {
            font-size: 11px;
            color: #9ca3af;
        }

        .gantt-timeline {
            overflow-x: auto;
            background: white;
        }

        .gantt-timeline-header {
            display: flex;
            border-bottom: 2px solid #e5e7eb;
            background: #f9fafb;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .gantt-time-cell {
            padding: 12px 8px;
            text-align: center;
            border-right: 1px solid #f3f4f6;
            font-size: 12px;
            font-weight: 500;
            min-width: 80px;
        }

        .gantt-bar-row {
            display: flex;
            border-bottom: 1px solid #f3f4f6;
            height: 49px;
            position: relative;
        }

        .gantt-bar-cell {
            border-right: 1px solid #f3f4f6;
            min-width: 80px;
            position: relative;
        }

        .gantt-bar {
            position: absolute;
            height: 28px;
            top: 10px;
            background: #3b82f6;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            color: white;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 2;
        }

        .gantt-bar:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            z-index: 3;
        }

        /* Mind Map View */
        .mindmap-view {
            position: relative;
            width: 100%;
            height: 100%;
            background: #f9fafb;
            overflow: hidden;
            border-radius: 8px;
        }

        .mindmap-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .mindmap-btn {
            padding: 8px 12px;
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }

        .mindmap-btn:hover {
            background: #f9fafb;
        }

        .mindmap-content {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .mindmap-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            will-change: transform;
        }

        .mindmap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        #mindmapNodes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .mindmap-node {
            position: absolute;
            background: white;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            user-select: none;
        }

        .mindmap-node:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 5;
        }

        .mindmap-node.root {
            background: #3b82f6;
            color: white;
            font-weight: 600;
            font-size: 16px;
            border-color: #2563eb;
        }

        .mindmap-node.level-1 {
            border-color: #8b5cf6;
        }

        .mindmap-node.level-2 {
            border-color: #ec4899;
        }

        .mindmap-node.level-3 {
            border-color: #f59e0b;
        }

        .mindmap-line {
            stroke: #cbd5e1;
            stroke-width: 2;
            fill: none;
        }

        /* Detail Panel */
        .detail-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background: white;
            border-left: 1px solid #e0e0e0;
            padding: 24px;
            overflow-y: auto;
            transition: right 0.3s;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .detail-panel.visible {
            right: 0;
        }

        .detail-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e5e7eb;
        }

        .detail-field {
            margin-bottom: 20px;
        }

        .detail-label {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .detail-input,
        .detail-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .detail-input:focus,
        .detail-select:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .detail-textarea {
            min-height: 100px;
            resize: vertical;
            font-family: inherit;
        }

        .detail-actions {
            display: flex;
            gap: 8px;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #e5e7eb;
        }

        .dependency-list {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .dependency-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: #f9fafb;
            border-radius: 4px;
            font-size: 13px;
        }

        .remove-dep {
            cursor: pointer;
            color: #ef4444;
            font-weight: bold;
            font-size: 18px;
            padding: 0 6px;
            transition: color 0.2s;
        }

        .remove-dep:hover {
            color: #dc2626;
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 2000;
        }

        .modal.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .add-task-btn {
            position: fixed;
            bottom: 32px;
            right: 32px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #3b82f6;
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transition: all 0.2s;
            z-index: 100;
        }

        .add-task-btn:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .toggle-descriptions,
        .link-mode-btn,
        .filter-clear,
        .outline-mode-btn,
        .dark-mode-btn {
            padding: 6px 12px;
            border: 1px solid #d0d0d0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .toggle-descriptions.active,
        .link-mode-btn.active,
        .outline-mode-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .link-mode-banner {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: #3b82f6;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
            z-index: 1001;
            font-size: 14px;
            font-weight: 500;
        }

        .link-mode-banner.visible {
            display: block;
        }

        /* Edit Mode */
        .edit-mode-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px);
            gap: 12px;
        }

        .edit-mode-help {
            padding: 12px;
            background: #eff6ff;
            border-left: 4px solid #3b82f6;
            border-radius: 4px;
            font-size: 13px;
            color: #1e40af;
        }

        .edit-mode-help code {
            background: #dbeafe;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .edit-mode-textarea {
            flex: 1;
            padding: 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            resize: none;
        }

        body.dark-mode .edit-mode-textarea {
            background: #1a1a1a;
            color: #e0e0e0;
            border-color: #404040;
        }

        .edit-mode-toolbar {
            display: flex;
            gap: 8px;
        }

        /* Global Settings Modal Styles */
        .settings-modal-content {
            max-width: 700px;
            width: 95%;
        }

        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-modal-btn {
            background: none;
            border: none;
            font-size: 32px;
            color: #999;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-modal-btn:hover {
            color: #333;
        }

        body.dark-mode .close-modal-btn {
            color: #666;
        }

        body.dark-mode .close-modal-btn:hover {
            color: #ccc;
        }

        .settings-tabs {
            display: flex;
            gap: 4px;
            border-bottom: 2px solid #e0e0e0;
            margin-bottom: 20px;
        }

        body.dark-mode .settings-tabs {
            border-bottom-color: #404040;
        }

        .settings-tab {
            padding: 10px 16px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }

        .settings-tab:hover {
            color: #333;
            background: #f5f5f5;
        }

        .settings-tab.active {
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }

        body.dark-mode .settings-tab {
            color: #999;
        }

        body.dark-mode .settings-tab:hover {
            color: #ccc;
            background: #333;
        }

        body.dark-mode .settings-tab.active {
            color: #3b82f6;
        }

        .settings-tab-content {
            min-height: 300px;
            max-height: 50vh;
            overflow-y: auto;
        }

        .settings-tab-panel {
            display: none;
        }

        .settings-tab-panel.active {
            display: block;
        }

        .settings-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .setting-subsection-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-top: 12px;
            margin-bottom: 4px;
        }

        body.dark-mode .setting-subsection-title {
            color: #999;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .setting-item.color-setting {
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
        }

        .setting-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 14px;
        }

        .setting-label-text {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }

        body.dark-mode .setting-label-text {
            color: #e0e0e0;
        }

        .setting-description {
            font-size: 12px;
            color: #666;
            margin-left: 30px;
        }

        body.dark-mode .setting-description {
            color: #999;
        }

        .setting-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .setting-select {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        body.dark-mode .setting-select {
            background: #1a1a1a;
            border-color: #404040;
            color: #e0e0e0;
        }

        .setting-color {
            width: 60px;
            height: 36px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
        }

        body.dark-mode .setting-color {
            border-color: #404040;
        }

        .setting-input {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            font-size: 18px;
            text-align: center;
            width: 60px;
        }

        body.dark-mode .setting-input {
            background: #1a1a1a;
            border-color: #404040;
            color: #e0e0e0;
        }

        .settings-btn {
            padding: 6px 12px;
            border: none;
            background: #f5f5f5;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .settings-btn:hover {
            background: #e0e0e0;
        }

        body.dark-mode .settings-btn {
            background: #333;
            color: #e0e0e0;
        }

        body.dark-mode .settings-btn:hover {
            background: #404040;
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="toolbar">
            <div class="view-switcher">
                <button class="view-btn active" data-view="outline">üìã Outline</button>
                <button class="view-btn" data-view="kanban">üìä Kanban</button>
                <button class="view-btn" data-view="gantt">üìÖ Gantt</button>
                <button class="view-btn" data-view="mindmap">üß† Mind Map</button>
            </div>

            <div class="filters">
                <button class="settings-btn" id="settingsBtn">‚öôÔ∏è Settings</button>
            </div>
        </div>

        <!-- Settings Pane - View-Specific Controls -->
        <div class="settings-pane" id="settingsPane">
            <!-- Content will be dynamically populated based on current view -->
        </div>

        <div class="link-mode-banner" id="linkModeBanner">
            üîó Link Mode Active: Click a task to set as source, then click another to create dependency
        </div>

        <div class="main-content">
            <div class="view-container" id="viewContainer"></div>
        </div>

        <button class="add-task-btn" id="addTaskBtn">+</button>
    </div>

    <!-- Detail Panel -->
    <div class="detail-panel" id="detailPanel"></div>

    <!-- Add Task Modal -->
    <div class="modal" id="addTaskModal">
        <div class="modal-content">
            <div class="modal-header">Add New Task</div>
            
            <div class="detail-field">
                <div class="detail-label">Task Title</div>
                <input type="text" class="detail-input" id="newTaskTitle" placeholder="Enter task title">
            </div>

            <div class="detail-field">
                <div class="detail-label">Description</div>
                <textarea class="detail-input detail-textarea" id="newTaskDescription" placeholder="Optional description"></textarea>
            </div>

            <div class="detail-field">
                <div class="detail-label">Parent Task</div>
                <select class="detail-select" id="newTaskParent">
                    <option value="">None (Top Level)</option>
                </select>
            </div>

            <div class="detail-actions">
                <button class="btn btn-primary" id="createTask">Create Task</button>
                <button class="btn btn-secondary" id="cancelModal">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Node Modal (for Mind Map) -->
    <div class="modal" id="nodeModal">
        <div class="modal-content" id="nodeModalContent">
        </div>
    </div>

    <!-- Global Settings Modal -->
    <div class="modal" id="globalSettingsModal">
        <div class="modal-content settings-modal-content">
            <div class="modal-header">
                ‚öôÔ∏è Global Settings
                <button class="close-modal-btn" id="closeSettingsModal">√ó</button>
            </div>

            <div class="settings-tabs">
                <button class="settings-tab active" data-tab="behavior">Behavior</button>
                <button class="settings-tab" data-tab="theme">Theme & Colors</button>
                <button class="settings-tab" data-tab="icons">Icons & Emojis</button>
                <button class="settings-tab" data-tab="mindmap">Mind Map</button>
            </div>

            <div class="settings-tab-content">
                <!-- Behavior Tab -->
                <div class="settings-tab-panel active" data-panel="behavior">
                    <div class="settings-section">
                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="setting-filterToggleBehavior" class="setting-checkbox">
                                <span>Filter Toggle Behavior</span>
                            </label>
                            <div class="setting-description">Allow deselecting filters (click active filter to show all)</div>
                        </div>

                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="setting-autoSave" class="setting-checkbox">
                                <span>Auto-Save</span>
                            </label>
                            <div class="setting-description">Automatically save changes to local storage</div>
                        </div>

                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="setting-darkMode" class="setting-checkbox">
                                <span>Dark Mode</span>
                            </label>
                            <div class="setting-description">Use dark theme throughout the app</div>
                        </div>

                        <div class="setting-item">
                            <div class="setting-label-text">Default View</div>
                            <select id="setting-defaultView" class="setting-select">
                                <option value="outline">üìã Outline</option>
                                <option value="kanban">üìä Kanban</option>
                                <option value="gantt">üìÖ Gantt</option>
                                <option value="mindmap">üß† Mind Map</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Theme & Colors Tab -->
                <div class="settings-tab-panel" data-panel="theme">
                    <div class="settings-section">
                        <div class="setting-subsection-title">Status Colors</div>

                        <div class="setting-item color-setting">
                            <label class="setting-label-text">Todo</label>
                            <input type="color" id="setting-color-todo" class="setting-color" value="#94a3b8">
                        </div>

                        <div class="setting-item color-setting">
                            <label class="setting-label-text">In Progress</label>
                            <input type="color" id="setting-color-in-progress" class="setting-color" value="#3b82f6">
                        </div>

                        <div class="setting-item color-setting">
                            <label class="setting-label-text">Review</label>
                            <input type="color" id="setting-color-review" class="setting-color" value="#f59e0b">
                        </div>

                        <div class="setting-item color-setting">
                            <label class="setting-label-text">Done</label>
                            <input type="color" id="setting-color-done" class="setting-color" value="#10b981">
                        </div>

                        <div class="setting-subsection-title">Priority Colors</div>

                        <div class="setting-item color-setting">
                            <label class="setting-label-text">High Priority</label>
                            <input type="color" id="setting-color-priority-high" class="setting-color" value="#ef4444">
                        </div>

                        <div class="setting-item color-setting">
                            <label class="setting-label-text">Medium Priority</label>
                            <input type="color" id="setting-color-priority-medium" class="setting-color" value="#f59e0b">
                        </div>

                        <div class="setting-item color-setting">
                            <label class="setting-label-text">Low Priority</label>
                            <input type="color" id="setting-color-priority-low" class="setting-color" value="#94a3b8">
                        </div>
                    </div>
                </div>

                <!-- Icons & Emojis Tab -->
                <div class="settings-tab-panel" data-panel="icons">
                    <div class="settings-section">
                        <div class="setting-subsection-title">Status Icons</div>

                        <div class="setting-item">
                            <label class="setting-label-text">Todo Icon</label>
                            <input type="text" id="setting-icon-todo" class="setting-input" value="‚óã" maxlength="2">
                        </div>

                        <div class="setting-item">
                            <label class="setting-label-text">In Progress Icon</label>
                            <input type="text" id="setting-icon-in-progress" class="setting-input" value="‚ö°" maxlength="2">
                        </div>

                        <div class="setting-item">
                            <label class="setting-label-text">Review Icon</label>
                            <input type="text" id="setting-icon-review" class="setting-input" value="üëÅ" maxlength="2">
                        </div>

                        <div class="setting-item">
                            <label class="setting-label-text">Done Icon</label>
                            <input type="text" id="setting-icon-done" class="setting-input" value="‚úì" maxlength="2">
                        </div>
                    </div>
                </div>

                <!-- Mind Map Tab -->
                <div class="settings-tab-panel" data-panel="mindmap">
                    <div class="settings-section">
                        <div class="setting-item">
                            <div class="setting-label-text">Line Style</div>
                            <select id="setting-mindMapLineStyle" class="setting-select">
                                <option value="straight">Straight Lines</option>
                                <option value="curved">Curved Lines</option>
                                <option value="right-angles">Right Angles</option>
                            </select>
                        </div>

                        <div class="setting-item">
                            <label class="setting-label">
                                <input type="checkbox" id="setting-showDescriptionsOnNodes" class="setting-checkbox">
                                <span>Show Descriptions on Nodes</span>
                            </label>
                            <div class="setting-description">Display task descriptions directly on Mind Map nodes</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="detail-actions">
                <button class="btn btn-primary" id="saveSettings">Save Settings</button>
                <button class="btn btn-secondary" id="resetSettings">Reset to Defaults</button>
                <button class="btn btn-secondary" id="cancelSettings">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Settings Manager - Global and View-Specific Settings
        class Settings {
            constructor() {
                this.storageKey = 'taskManagerSettings';

                // Default settings
                this.defaults = {
                    // Global settings
                    filterToggleBehavior: true,  // true = can deselect filters, false = traditional radio
                    mindMapLineStyle: 'straight',
                    showDescriptionsOnNodes: false,
                    defaultView: 'outline',
                    darkMode: false,
                    autoSave: true,

                    // View-specific settings
                    outline: {
                        showDescriptions: false,
                        indentSize: 20,
                        checkboxMode: false,
                        sortBy: 'default'
                    },
                    kanban: {
                        cardSize: 'normal',
                        columnOrder: ['todo', 'in-progress', 'review', 'done'],
                        showMetadata: true
                    },
                    gantt: {
                        dateRange: 'month',
                        showDependencyLines: false,
                        zoomLevel: 1
                    },
                    mindmap: {
                        layoutMode: 'tree',
                        nodeSize: 'medium'
                    }
                };

                // Load saved settings or use defaults
                this.settings = this.load();
            }

            load() {
                try {
                    const saved = localStorage.getItem(this.storageKey);
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // Merge with defaults to handle new settings added in updates
                        return this.mergeDeep(this.defaults, parsed);
                    }
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
                return JSON.parse(JSON.stringify(this.defaults)); // Deep copy
            }

            save() {
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.settings));
                } catch (e) {
                    console.error('Failed to save settings:', e);
                }
            }

            get(path) {
                const keys = path.split('.');
                let value = this.settings;
                for (const key of keys) {
                    if (value && typeof value === 'object') {
                        value = value[key];
                    } else {
                        return undefined;
                    }
                }
                return value;
            }

            set(path, value) {
                const keys = path.split('.');
                let obj = this.settings;
                for (let i = 0; i < keys.length - 1; i++) {
                    const key = keys[i];
                    if (!obj[key] || typeof obj[key] !== 'object') {
                        obj[key] = {};
                    }
                    obj = obj[key];
                }
                obj[keys[keys.length - 1]] = value;
                this.save();
            }

            reset() {
                this.settings = JSON.parse(JSON.stringify(this.defaults));
                this.save();
            }

            mergeDeep(target, source) {
                const result = JSON.parse(JSON.stringify(target));
                for (const key in source) {
                    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                        result[key] = this.mergeDeep(result[key] || {}, source[key]);
                    } else {
                        result[key] = source[key];
                    }
                }
                return result;
            }
        }

        // Task Store - Single source of truth
        class TaskStore {
            constructor() {
                this.tasks = this.getInitialData();
                this.nextId = 100;
                this.collapsed = new Set();
                this.dependencies = new Map();
                this.observers = [];
                this.filter = 'all';
                this.searchQuery = '';
                this.showDescriptions = false;
                this.editMode = false;
                this.sortByPriority = false;
                this.showPriorityInGantt = true;

                // Undo/Redo system
                this.history = [];
                this.historyIndex = -1;
                this.maxHistorySize = 50;

                // Save initial state
                this.saveState();
            }

            saveState() {
                // Create a deep copy of current state
                const state = {
                    tasks: JSON.parse(JSON.stringify(this.tasks)),
                    dependencies: new Map(this.dependencies),
                    nextId: this.nextId
                };
                
                // Remove any states after current index (when making changes after undo)
                this.history = this.history.slice(0, this.historyIndex + 1);
                
                // Add new state
                this.history.push(state);
                
                // Limit history size
                if (this.history.length > this.maxHistorySize) {
                    this.history.shift();
                } else {
                    this.historyIndex++;
                }
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState(this.history[this.historyIndex]);
                    this.notify();
                    return true;
                }
                return false;
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState(this.history[this.historyIndex]);
                    this.notify();
                    return true;
                }
                return false;
            }

            restoreState(state) {
                this.tasks = JSON.parse(JSON.stringify(state.tasks));
                this.dependencies = new Map(state.dependencies);
                this.nextId = state.nextId;
            }

            subscribe(callback) {
                this.observers.push(callback);
            }

            notify() {
                this.observers.forEach(callback => callback());
            }

            addTask(parentId, title, description = '') {
                const newTask = {
                    id: String(this.nextId++),
                    title,
                    description,
                    metadata: {
                        status: 'todo',
                        priority: 'medium',
                        assignee: '',
                        startDate: '',
                        endDate: ''
                    },
                    children: []
                };

                if (parentId) {
                    const parent = this.findTask(parentId);
                    if (parent) {
                        parent.children.push(newTask);
                    }
                } else {
                    this.tasks.push(newTask);
                }

                this.saveState();
                this.notify();
                return newTask.id; // Return the new task ID
            }

            findTask(id, tasks = this.tasks) {
                for (const task of tasks) {
                    if (task.id === id) return task;
                    if (task.children) {
                        const found = this.findTask(id, task.children);
                        if (found) return found;
                    }
                }
                return null;
            }

            findParent(childId, tasks = this.tasks, parent = null) {
                for (const task of tasks) {
                    if (task.id === childId) return parent;
                    if (task.children) {
                        const found = this.findParent(childId, task.children, task);
                        if (found !== null) return found;
                    }
                }
                return null;
            }

            deleteTask(id, tasks = this.tasks) {
                for (let i = 0; i < tasks.length; i++) {
                    if (tasks[i].id === id) {
                        tasks.splice(i, 1);
                        this.saveState();
                        this.notify();
                        return true;
                    }
                    if (tasks[i].children) {
                        if (this.deleteTask(id, tasks[i].children)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            updateTask(id, updates) {
                const task = this.findTask(id);
                if (!task) return;

                Object.keys(updates).forEach(key => {
                    if (key.startsWith('metadata.')) {
                        const metaKey = key.split('.')[1];
                        task.metadata[metaKey] = updates[key];
                    } else {
                        task[key] = updates[key];
                    }
                });

                this.saveState();
                this.notify();
            }

            toggleCollapse(id) {
                if (this.collapsed.has(id)) {
                    this.collapsed.delete(id);
                } else {
                    this.collapsed.add(id);
                }
                this.notify();
            }

            getFlatTasks(tasks = this.tasks) {
                let flat = [];
                tasks.forEach(task => {
                    flat.push(task);
                    if (task.children) {
                        flat = flat.concat(this.getFlatTasks(task.children));
                    }
                });
                return flat;
            }

            getFilteredTasks() {
                const filterTasks = (tasks) => {
                    return tasks.map(task => {
                        const taskCopy = { ...task, children: task.children ? [...task.children] : [] };

                        // Apply search filter
                        const matchesSearch = !this.searchQuery ||
                            task.title.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                            (task.description && task.description.toLowerCase().includes(this.searchQuery.toLowerCase()));

                        // Apply status filter
                        const matchesStatus = this.filter === 'all' || task.metadata.status === this.filter;

                        taskCopy._matches = matchesSearch && matchesStatus;

                        // Recursively filter children
                        if (taskCopy.children && taskCopy.children.length > 0) {
                            taskCopy.children = filterTasks(taskCopy.children);
                        }

                        return taskCopy;
                    });
                };

                const sortTasksByPriority = (tasks) => {
                    // Priority order: high (0) ‚Üí medium (1) ‚Üí low (2)
                    const priorityOrder = { high: 0, medium: 1, low: 2 };

                    return tasks.map(task => {
                        const taskCopy = { ...task };

                        // Recursively sort children
                        if (taskCopy.children && taskCopy.children.length > 0) {
                            taskCopy.children = sortTasksByPriority([...taskCopy.children]);
                        }

                        return taskCopy;
                    }).sort((a, b) => {
                        const aPriority = priorityOrder[a.metadata.priority || 'medium'];
                        const bPriority = priorityOrder[b.metadata.priority || 'medium'];
                        return aPriority - bPriority;
                    });
                };

                let tasks = filterTasks(this.tasks);

                // Apply priority sorting if enabled
                if (this.sortByPriority) {
                    tasks = sortTasksByPriority(tasks);
                }

                return tasks;
            }

            tasksToOutlineText(tasks = this.tasks, depth = 0) {
                let text = '';
                tasks.forEach(task => {
                    const indent = '  '.repeat(depth);
                    const description = task.description ? ` # ${task.description}` : '';
                    
                    // Encode metadata inline with special markers
                    const meta = [];
                    if (task.metadata.status && task.metadata.status !== 'todo') {
                        meta.push(`@status:${task.metadata.status}`);
                    }
                    if (task.metadata.priority && task.metadata.priority !== 'medium') {
                        meta.push(`@priority:${task.metadata.priority}`);
                    }
                    if (task.metadata.assignee) {
                        meta.push(`@assignee:${task.metadata.assignee}`);
                    }
                    if (task.metadata.startDate) {
                        meta.push(`@start:${task.metadata.startDate}`);
                    }
                    if (task.metadata.endDate) {
                        meta.push(`@end:${task.metadata.endDate}`);
                    }
                    if (meta.length > 0) {
                        meta.unshift(''); // Add space before first @
                    }
                    
                    const metaStr = meta.length > 0 ? ` [${meta.join(' ')}]` : '';
                    
                    text += `${indent}${task.title}${description}${metaStr}\n`;
                    if (task.children && task.children.length > 0) {
                        text += this.tasksToOutlineText(task.children, depth + 1);
                    }
                });
                return text;
            }

            outlineTextToTasks(text) {
                const lines = text.split('\n').filter(line => line.trim());
                const root = [];
                const stack = [{ children: root, depth: -1 }];
                
                // Create a map of existing tasks by ID for metadata preservation
                const existingTasksMap = new Map();
                const flatExisting = this.getFlatTasks();
                flatExisting.forEach(task => {
                    existingTasksMap.set(task.id, task);
                });
                
                // Also map by title as fallback
                const existingByTitle = new Map();
                flatExisting.forEach(task => {
                    existingByTitle.set(task.title.toLowerCase(), task);
                });

                lines.forEach((line, lineNum) => {
                    // Count leading spaces
                    const leadingSpaces = line.search(/\S/);
                    if (leadingSpaces === -1) return; // Empty line
                    
                    const depth = Math.floor(leadingSpaces / 2);
                    let content = line.trim();
                    
                    if (!content) return;
                    
                    // Extract metadata if present [...]
                    let metadata = {
                        status: 'todo',
                        priority: 'medium',
                        assignee: '',
                        startDate: '',
                        endDate: ''
                    };
                    
                    const metaMatch = content.match(/\[([^\]]+)\]$/);
                    if (metaMatch) {
                        content = content.substring(0, metaMatch.index).trim();
                        const metaParts = metaMatch[1].trim().split(/\s+/);
                        
                        metaParts.forEach(part => {
                            if (part.startsWith('@status:')) {
                                metadata.status = part.substring(8);
                            } else if (part.startsWith('@priority:')) {
                                metadata.priority = part.substring(10);
                            } else if (part.startsWith('@assignee:')) {
                                metadata.assignee = part.substring(10);
                            } else if (part.startsWith('@start:')) {
                                metadata.startDate = part.substring(7);
                            } else if (part.startsWith('@end:')) {
                                metadata.endDate = part.substring(5);
                            }
                        });
                    }
                    
                    // Split title and description
                    const [title, ...descParts] = content.split('#').map(s => s.trim());
                    const description = descParts.join('#').trim();

                    if (!title) return;

                    // Try to find existing task by title to preserve ID
                    const existingTask = existingByTitle.get(title.toLowerCase());
                    
                    const task = {
                        id: existingTask ? existingTask.id : String(this.nextId++),
                        title,
                        description: description || (existingTask ? existingTask.description : ''),
                        metadata: metadata,
                        children: []
                    };

                    // Pop stack to correct depth
                    while (stack.length > 1 && stack[stack.length - 1].depth >= depth) {
                        stack.pop();
                    }

                    // Add to parent
                    if (stack.length > 0) {
                        stack[stack.length - 1].children.push(task);
                        stack.push({ children: task.children, depth });
                    }
                });

                return root;
            }

            parseOutlineAndUpdate(text) {
                try {
                    this.tasks = this.outlineTextToTasks(text);
                    this.saveState();
                    this.notify();
                    return true;
                } catch (error) {
                    console.error('Parse error:', error);
                    return false;
                }
            }

            getInitialData() {
                // Initialize with some dependencies
                setTimeout(() => {
                    this.addDependency('1-2-1', '1-1-2'); // Wireframes depends on Analytics review
                    this.addDependency('1-3-1', '1-2-2'); // Frontend depends on Visual design
                }, 100);
                
                return [
                    {
                        id: '1',
                        title: 'Launch Website',
                        description: 'Complete website redesign and launch',
                        metadata: {
                            status: 'in-progress',
                            priority: 'high',
                            assignee: 'JS',
                            startDate: '2024-12-01',
                            endDate: '2024-12-31'
                        },
                        children: [
                            {
                                id: '1-1',
                                title: 'Research',
                                description: 'User research and competitive analysis phase',
                                metadata: { status: 'in-progress', priority: 'high', assignee: 'JS', startDate: '2024-12-01', endDate: '2024-12-10' },
                                children: [
                                    { id: '1-1-1', title: 'User interviews', description: 'Conduct 10 user interviews', metadata: { status: 'done', priority: 'medium', assignee: 'JS', startDate: '2024-12-01', endDate: '2024-12-05' }, children: [] },
                                    { id: '1-1-2', title: 'Analytics review', description: 'Review current site analytics', metadata: { status: 'in-progress', priority: 'high', assignee: 'JS', startDate: '2024-12-05', endDate: '2024-12-10' }, children: [] },
                                    { id: '1-1-3', title: 'Competitor analysis', description: 'Analyze top 5 competitors', metadata: { status: 'todo', priority: 'medium', assignee: 'AB', startDate: '2024-12-08', endDate: '2024-12-12' }, children: [] }
                                ]
                            },
                            {
                                id: '1-2',
                                title: 'Design',
                                description: 'UI/UX design phase',
                                metadata: { status: 'todo', priority: 'high', assignee: 'AB', startDate: '2024-12-11', endDate: '2024-12-20' },
                                children: [
                                    { id: '1-2-1', title: 'Wireframes', description: 'Create wireframes for all pages', metadata: { status: 'todo', priority: 'high', assignee: 'AB', startDate: '2024-12-11', endDate: '2024-12-15' }, children: [] },
                                    { id: '1-2-2', title: 'Visual design', description: 'High-fidelity mockups', metadata: { status: 'todo', priority: 'medium', assignee: 'AB', startDate: '2024-12-16', endDate: '2024-12-20' }, children: [] }
                                ]
                            },
                            {
                                id: '1-3',
                                title: 'Development',
                                description: 'Implementation phase',
                                metadata: { status: 'todo', priority: 'high', assignee: 'JS', startDate: '2024-12-15', endDate: '2024-12-28' },
                                children: [
                                    { id: '1-3-1', title: 'Frontend', description: 'Build React components', metadata: { status: 'todo', priority: 'high', assignee: 'JS', startDate: '2024-12-15', endDate: '2024-12-22' }, children: [] },
                                    { id: '1-3-2', title: 'Backend API', description: 'REST API development', metadata: { status: 'todo', priority: 'high', assignee: 'JS', startDate: '2024-12-18', endDate: '2024-12-25' }, children: [] },
                                    { id: '1-3-3', title: 'Testing', description: 'QA and bug fixes', metadata: { status: 'todo', priority: 'medium', assignee: 'AB', startDate: '2024-12-23', endDate: '2024-12-28' }, children: [] }
                                ]
                            }
                        ]
                    }
                ];
            }

            addDependency(taskId, dependsOnId) {
                if (!this.dependencies.has(taskId)) {
                    this.dependencies.set(taskId, []);
                }
                const deps = this.dependencies.get(taskId);
                if (!deps.includes(dependsOnId)) {
                    deps.push(dependsOnId);
                    this.saveState();
                    this.notify();
                }
            }

            removeDependency(taskId, dependsOnId) {
                if (this.dependencies.has(taskId)) {
                    const deps = this.dependencies.get(taskId);
                    const index = deps.indexOf(dependsOnId);
                    if (index > -1) {
                        deps.splice(index, 1);
                        this.saveState();
                        this.notify();
                    }
                }
            }

            getDependencies(taskId) {
                return this.dependencies.get(taskId) || [];
            }
        }

        // Main App
        class App {
            constructor() {
                // Initialize settings first
                this.settings = new Settings();

                this.store = new TaskStore();
                this.currentView = this.settings.get('defaultView') || 'outline';
                this.linkMode = false;
                this.linkSource = null;
                this.selectedTask = null;

                // Initialize Mind Map mode from settings
                this.mindmapMode = this.settings.get('mindmap.layoutMode') || 'tree';

                // Apply dark mode from settings
                const darkMode = this.settings.get('darkMode');
                if (darkMode) {
                    document.body.classList.add('dark-mode');
                }

                this.store.subscribe(() => this.render());
                this.setupEventListeners();
                this.render();
            }

            setupEventListeners() {
                // View switcher
                document.querySelectorAll('[data-view]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('[data-view]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentView = e.target.dataset.view;
                        // Save current view as default
                        this.settings.set('defaultView', this.currentView);
                        this.render();
                    });
                });

                // Filter buttons, search box, toggle descriptions, and link mode are now handled in renderSettingsPane()

                // Settings button
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    this.openSettingsModal();
                });

                // Add task button
                document.getElementById('addTaskBtn').addEventListener('click', () => {
                    this.showAddTaskModal();
                });

                // Modal buttons
                document.getElementById('createTask').addEventListener('click', () => {
                    const title = document.getElementById('newTaskTitle').value.trim();
                    const parent = document.getElementById('newTaskParent').value;
                    const description = document.getElementById('newTaskDescription').value.trim();
                    
                    if (title) {
                        this.store.addTask(parent || null, title, description);
                        this.closeAddTaskModal();
                    } else {
                        alert('Please enter a task title');
                    }
                });

                document.getElementById('cancelModal').addEventListener('click', () => {
                    this.closeAddTaskModal();
                });

                // Global keyboard shortcuts for undo/redo
                document.addEventListener('keydown', (e) => {
                    // Prevent Tab navigation when in outline view
                    if (this.currentView === 'outline' && e.key === 'Tab') {
                        // Check if we're NOT editing a task title
                        const activeElement = document.activeElement;
                        const isEditingTitle = activeElement && 
                                              activeElement.getAttribute('contenteditable') === 'true' &&
                                              activeElement.classList.contains('task-title');
                        
                        if (!isEditingTitle) {
                            e.preventDefault();
                            e.stopPropagation();
                            return false;
                        }
                    }
                    
                    // Ctrl+Z or Cmd+Z for undo
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        if (this.store.undo()) {
                            this.showToast('Undo');
                        }
                    }
                    // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z for redo
                    else if (((e.ctrlKey || e.metaKey) && e.key === 'y') || 
                             ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z')) {
                        e.preventDefault();
                        if (this.store.redo()) {
                            this.showToast('Redo');
                        }
                    }
                });
            }

            showToast(message) {
                // Create or reuse toast element
                let toast = document.getElementById('undoToast');
                if (!toast) {
                    toast = document.createElement('div');
                    toast.id = 'undoToast';
                    toast.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        background: rgba(0, 0, 0, 0.8);
                        color: white;
                        padding: 12px 20px;
                        border-radius: 6px;
                        font-size: 14px;
                        z-index: 10000;
                        opacity: 0;
                        transition: opacity 0.3s;
                    `;
                    document.body.appendChild(toast);
                }
                
                toast.textContent = message;
                toast.style.opacity = '1';
                
                setTimeout(() => {
                    toast.style.opacity = '0';
                }, 1500);
            }

            showAddTaskModal() {
                // Populate parent dropdown
                const select = document.getElementById('newTaskParent');
                select.innerHTML = '<option value="">None (Top Level)</option>';
                
                const addOptions = (tasks, prefix = '') => {
                    tasks.forEach(task => {
                        select.innerHTML += `<option value="${task.id}">${prefix}${task.title}</option>`;
                        if (task.children) {
                            addOptions(task.children, prefix + '  ');
                        }
                    });
                };
                
                addOptions(this.store.tasks);
                
                // Reset form
                document.getElementById('newTaskTitle').value = '';
                document.getElementById('newTaskDescription').value = '';
                
                document.getElementById('addTaskModal').classList.add('visible');
            }

            closeAddTaskModal() {
                document.getElementById('addTaskModal').classList.remove('visible');
            }

            openSettingsModal() {
                // Populate settings from current state
                this.populateSettingsModal();

                // Set up tab switching
                const tabButtons = document.querySelectorAll('.settings-tab');
                const tabPanels = document.querySelectorAll('.settings-tab-panel');

                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const targetTab = button.getAttribute('data-tab');

                        // Update active tab button
                        tabButtons.forEach(b => b.classList.remove('active'));
                        button.classList.add('active');

                        // Update active tab panel
                        tabPanels.forEach(p => {
                            if (p.getAttribute('data-panel') === targetTab) {
                                p.classList.add('active');
                            } else {
                                p.classList.remove('active');
                            }
                        });
                    });
                });

                // Set up modal action buttons
                document.getElementById('saveSettings').onclick = () => this.saveSettingsModal();
                document.getElementById('resetSettings').onclick = () => this.resetSettingsModal();
                document.getElementById('cancelSettings').onclick = () => this.closeSettingsModal();
                document.getElementById('closeSettingsModal').onclick = () => this.closeSettingsModal();

                // Show modal
                document.getElementById('globalSettingsModal').classList.add('visible');
            }

            closeSettingsModal() {
                document.getElementById('globalSettingsModal').classList.remove('visible');
            }

            populateSettingsModal() {
                // Behavior tab
                document.getElementById('setting-filterToggleBehavior').checked = this.settings.get('filterToggleBehavior');
                document.getElementById('setting-autoSave').checked = this.settings.get('autoSave');
                document.getElementById('setting-darkMode').checked = this.settings.get('darkMode');
                document.getElementById('setting-defaultView').value = this.settings.get('defaultView');

                // Mind Map tab
                document.getElementById('setting-mindMapLineStyle').value = this.settings.get('mindMapLineStyle');
                document.getElementById('setting-showDescriptionsOnNodes').checked = this.settings.get('showDescriptionsOnNodes');
            }

            saveSettingsModal() {
                // Save behavior settings
                this.settings.set('filterToggleBehavior', document.getElementById('setting-filterToggleBehavior').checked);
                this.settings.set('autoSave', document.getElementById('setting-autoSave').checked);

                // Handle dark mode
                const darkMode = document.getElementById('setting-darkMode').checked;
                this.settings.set('darkMode', darkMode);
                document.body.classList.toggle('dark-mode', darkMode);

                this.settings.set('defaultView', document.getElementById('setting-defaultView').value);

                // Save Mind Map settings
                this.settings.set('mindMapLineStyle', document.getElementById('setting-mindMapLineStyle').value);
                this.settings.set('showDescriptionsOnNodes', document.getElementById('setting-showDescriptionsOnNodes').checked);

                // Close modal and show confirmation
                this.closeSettingsModal();
                this.showToast('Settings saved');
            }

            resetSettingsModal() {
                if (confirm('Reset all settings to defaults? This cannot be undone.')) {
                    this.settings.reset();
                    this.populateSettingsModal();

                    // Apply dark mode reset
                    document.body.classList.toggle('dark-mode', this.settings.get('darkMode'));

                    this.showToast('Settings reset to defaults');
                    this.render();
                }
            }

            renderSettingsPane() {
                const pane = document.getElementById('settingsPane');
                pane.innerHTML = '';

                // View-specific settings configurations
                const settingsConfig = {
                    outline: [
                        {
                            type: 'group',
                            label: 'Filter',
                            items: [
                                { type: 'button', text: 'To Do', filter: 'todo', active: this.store.filter === 'todo' },
                                { type: 'button', text: 'In Progress', filter: 'in-progress', active: this.store.filter === 'in-progress' },
                                { type: 'button', text: 'Done', filter: 'done', active: this.store.filter === 'done' }
                            ]
                        },
                        { type: 'divider' },
                        {
                            type: 'input',
                            placeholder: 'Search tasks...',
                            value: this.store.searchQuery,
                            id: 'searchBox'
                        },
                        { type: 'divider' },
                        {
                            type: 'single-button',
                            text: this.store.showDescriptions ? 'Hide Descriptions' : 'Show Descriptions',
                            id: 'toggleDescriptions'
                        },
                        { type: 'divider' },
                        {
                            type: 'single-button',
                            text: 'üîó Link Mode',
                            id: 'linkModeBtn',
                            active: this.linkMode
                        },
                        { type: 'divider' },
                        {
                            type: 'single-button',
                            text: this.store.sortByPriority ? '‚ÜïÔ∏è Sort: Priority' : '‚ÜïÔ∏è Sort: Default',
                            id: 'sortByPriorityBtn',
                            active: this.store.sortByPriority
                        }
                    ],
                    kanban: [
                        {
                            type: 'group',
                            label: 'Filter',
                            items: [
                                { type: 'button', text: 'To Do', filter: 'todo', active: this.store.filter === 'todo' },
                                { type: 'button', text: 'In Progress', filter: 'in-progress', active: this.store.filter === 'in-progress' },
                                { type: 'button', text: 'Done', filter: 'done', active: this.store.filter === 'done' }
                            ]
                        },
                        { type: 'divider' },
                        {
                            type: 'input',
                            placeholder: 'Search tasks...',
                            value: this.store.searchQuery,
                            id: 'searchBox'
                        },
                        { type: 'divider' },
                        {
                            type: 'single-button',
                            text: this.store.sortByPriority ? '‚ÜïÔ∏è Sort: Priority' : '‚ÜïÔ∏è Sort: Default',
                            id: 'sortByPriorityBtn',
                            active: this.store.sortByPriority
                        }
                    ],
                    gantt: [
                        {
                            type: 'group',
                            label: 'Filter',
                            items: [
                                { type: 'button', text: 'To Do', filter: 'todo', active: this.store.filter === 'todo' },
                                { type: 'button', text: 'In Progress', filter: 'in-progress', active: this.store.filter === 'in-progress' },
                                { type: 'button', text: 'Done', filter: 'done', active: this.store.filter === 'done' }
                            ]
                        },
                        { type: 'divider' },
                        {
                            type: 'input',
                            placeholder: 'Search tasks...',
                            value: this.store.searchQuery,
                            id: 'searchBox'
                        },
                        { type: 'divider' },
                        {
                            type: 'single-button',
                            text: this.store.showPriorityInGantt ? 'Hide Priority ‚ö†Ô∏è' : 'Show Priority ‚ö†Ô∏è',
                            id: 'togglePriorityGanttBtn',
                            active: this.store.showPriorityInGantt
                        }
                    ],
                    mindmap: [
                        {
                            type: 'group',
                            label: 'Layout',
                            items: [
                                { type: 'button', text: 'üå≥ Tree', mode: 'tree', active: this.mindmapMode === 'tree' },
                                { type: 'button', text: '‚≠ï Radial', mode: 'radial', active: this.mindmapMode === 'radial' }
                            ]
                        },
                        { type: 'divider' },
                        {
                            type: 'input',
                            placeholder: 'Search tasks...',
                            value: this.store.searchQuery,
                            id: 'searchBox'
                        }
                    ]
                };

                const config = settingsConfig[this.currentView] || [];

                config.forEach(item => {
                    if (item.type === 'group') {
                        const group = document.createElement('div');
                        group.className = 'setting-group';

                        if (item.label) {
                            const label = document.createElement('span');
                            label.className = 'setting-label';
                            label.textContent = item.label;
                            group.appendChild(label);
                        }

                        item.items.forEach(btn => {
                            const button = document.createElement('button');
                            button.className = 'setting-btn' + (btn.active ? ' active' : '');
                            button.textContent = btn.text;

                            if (btn.filter) {
                                button.dataset.filter = btn.filter;
                                button.addEventListener('click', () => {
                                    // Check if filter toggle behavior is enabled
                                    if (this.settings.get('filterToggleBehavior')) {
                                        // NEW: Toggle behavior - click active filter to deselect
                                        if (this.store.filter === btn.filter) {
                                            this.store.filter = 'all'; // Deselect = show all
                                        } else {
                                            this.store.filter = btn.filter; // Select
                                        }
                                    } else {
                                        // OLD: Traditional radio button behavior
                                        this.store.filter = btn.filter;
                                    }
                                    this.store.notify();
                                });
                            }

                            if (btn.mode) {
                                button.dataset.mode = btn.mode;
                                button.addEventListener('click', () => {
                                    this.mindmapMode = btn.mode;
                                    // Save to settings
                                    this.settings.set('mindmap.layoutMode', btn.mode);
                                    // Reset view state when changing modes
                                    this.mindmapPanX = undefined;
                                    this.mindmapPanY = undefined;
                                    this.mindmapScale = undefined;
                                    this.render();
                                });
                            }

                            group.appendChild(button);
                        });

                        pane.appendChild(group);
                    } else if (item.type === 'divider') {
                        const divider = document.createElement('div');
                        divider.className = 'divider';
                        pane.appendChild(divider);
                    } else if (item.type === 'input') {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'setting-input';
                        input.placeholder = item.placeholder;
                        input.value = item.value || '';
                        if (item.id) input.id = item.id;

                        input.addEventListener('input', (e) => {
                            this.store.searchQuery = e.target.value;
                            this.store.notify();
                        });

                        pane.appendChild(input);
                    } else if (item.type === 'single-button') {
                        const button = document.createElement('button');
                        button.className = 'setting-btn';
                        if (item.active) button.classList.add('active');
                        button.textContent = item.text;
                        if (item.id) button.id = item.id;

                        if (item.id === 'toggleDescriptions') {
                            button.addEventListener('click', () => {
                                this.store.showDescriptions = !this.store.showDescriptions;
                                this.render();
                            });
                        } else if (item.id === 'linkModeBtn') {
                            button.addEventListener('click', () => {
                                this.linkMode = !this.linkMode;
                                this.linkSource = null;
                                button.classList.toggle('active');
                                document.getElementById('linkModeBanner').classList.toggle('visible', this.linkMode);
                                this.render();
                            });
                        } else if (item.id === 'sortByPriorityBtn') {
                            button.addEventListener('click', () => {
                                this.store.sortByPriority = !this.store.sortByPriority;
                                button.classList.toggle('active');
                                this.render();
                            });
                        } else if (item.id === 'togglePriorityGanttBtn') {
                            button.addEventListener('click', () => {
                                this.store.showPriorityInGantt = !this.store.showPriorityInGantt;
                                button.classList.toggle('active');
                                this.render();
                            });
                        }

                        pane.appendChild(button);
                    }
                });
            }

            render() {
                // Render view-specific settings pane
                this.renderSettingsPane();

                const container = document.getElementById('viewContainer');

                switch(this.currentView) {
                    case 'outline':
                        this.renderOutline(container);
                        break;
                    case 'kanban':
                        this.renderKanban(container);
                        break;
                    case 'gantt':
                        this.renderGantt(container);
                        break;
                    case 'mindmap':
                        this.renderMindMap(container);
                        break;
                }
            }

            renderOutline(container) {
                // Inline editing mode - no separate edit mode anymore
                this.selectedTaskId = this.selectedTaskId || null;
                
                const renderTask = (task, depth = 0) => {
                    const isCollapsed = this.store.collapsed.has(task.id);
                    const hasChildren = task.children && task.children.length > 0;
                    const opacity = task._matches === false ? 0.4 : 1;
                    const dependencies = this.store.getDependencies(task.id);
                    const isSelected = this.selectedTaskId === task.id;
                    
                    let html = `
                        <div class="task-row ${isSelected ? 'selected' : ''}" style="margin-left: ${depth * 20}px; opacity: ${opacity}" data-task-id="${task.id}" data-depth="${depth}">
                            ${hasChildren ?
                                `<button class="collapse-btn" data-collapse="${task.id}">${isCollapsed ? '‚ñ∂' : '‚ñº'}</button>` :
                                '<span style="width: 20px"></span>'
                            }
                            <div class="status-icon status-${task.metadata.status}" data-task-click="${task.id}">
                                ${task.metadata.status === 'done' ? '‚úì' :
                                  task.metadata.status === 'in-progress' ? '‚ö°' :
                                  task.metadata.status === 'review' ? 'üëÅ' : '‚óã'}
                            </div>
                            <span class="task-title" data-task-click="${task.id}" contenteditable="true" data-original-title="${task.title}">${task.title}</span>
                            ${dependencies.length > 0 ? `<span class="dependency-badge">‚Üí ${dependencies.length}</span>` : ''}
                            ${task.metadata.assignee ? `<div class="assignee">${task.metadata.assignee}</div>` : ''}
                            ${task.metadata.priority === 'high' ? '<span class="priority-indicator" title="High Priority">‚ö†Ô∏è</span>' : ''}
                            ${isCollapsed && hasChildren ? `<span class="badge" style="background: #e0e0e0; color: #666">${task.children.length}</span>` : ''}
                        </div>
                    `;
                    
                    if (this.store.showDescriptions && task.description) {
                        html += `<div class="task-description" style="margin-left: ${depth * 20 + 48}px" contenteditable="true" data-task-id="${task.id}" data-original-desc="${task.description}">${task.description}</div>`;
                    } else if (this.store.showDescriptions) {
                        html += `<div class="task-description task-placeholder" style="margin-left: ${depth * 20 + 48}px" contenteditable="true" data-task-id="${task.id}" data-original-desc="">Click to add description...</div>`;
                    }
                    
                    if (!isCollapsed && hasChildren) {
                        html += task.children.map(child => renderTask(child, depth + 1)).join('');
                    }
                    
                    return html;
                };

                const tasks = this.store.getFilteredTasks();
                container.innerHTML = `
                    <div class="outline-view">
                        ${tasks.map(task => renderTask(task)).join('')}
                    </div>
                    <div class="inline-edit-hint" id="editHint">
                        üí° <strong>Enter</strong> = new sibling | <strong>Tab</strong> = indent | <strong>Shift+Tab</strong> = outdent | <strong>Delete</strong> = remove | <strong>Ctrl+Z</strong> = undo
                    </div>
                `;

                // Show hint briefly
                const hint = container.querySelector('#editHint');
                hint.classList.add('visible');
                setTimeout(() => hint.classList.remove('visible'), 4000);

                // Track current selection
                let currentSelection = this.selectedTaskId;

                // Event listeners for collapse
                container.querySelectorAll('[data-collapse]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.store.toggleCollapse(e.target.dataset.collapse);
                    });
                });

                // Event listeners for task rows
                container.querySelectorAll('.task-row').forEach(row => {
                    const taskId = row.dataset.taskId;
                    const depth = parseInt(row.dataset.depth);

                    // Click to select
                    row.addEventListener('click', (e) => {
                        if (e.target.classList.contains('collapse-btn')) return;
                        
                        // Remove previous selection
                        container.querySelectorAll('.task-row').forEach(r => r.classList.remove('selected'));
                        row.classList.add('selected');
                        this.selectedTaskId = taskId;
                        currentSelection = taskId;
                    });

                    // Inline title editing
                    const titleEl = row.querySelector('.task-title');
                    titleEl.addEventListener('blur', (e) => {
                        const newTitle = e.target.textContent.trim();
                        if (newTitle && newTitle !== e.target.dataset.originalTitle) {
                            this.store.updateTask(taskId, { title: newTitle });
                        } else if (!newTitle) {
                            e.target.textContent = e.target.dataset.originalTitle;
                        }
                    });

                    titleEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            titleEl.blur();
                        }
                    });

                    // Keyboard shortcuts
                    row.addEventListener('keydown', (e) => {
                        if (e.target.getAttribute('contenteditable') === 'true' && e.target.classList.contains('task-title')) {
                            // Allow Tab while editing to navigate away from title
                            if (e.key === 'Tab') {
                                return;
                            }
                        }

                        // Always prevent Tab from navigating to other elements
                        if (e.key === 'Tab') {
                            e.preventDefault();
                            e.stopPropagation();
                        }

                        if (e.key === 'Enter') {
                            e.preventDefault();
                            e.stopPropagation();
                            // Create sibling task
                            const task = this.store.findTask(taskId);
                            const parent = this.store.findParent(taskId);
                            
                            const newTaskTitle = 'New Task';
                            const newTaskId = this.store.addTask(parent ? parent.id : null, newTaskTitle, '');
                            
                            // Update selection to new task
                            this.selectedTaskId = newTaskId;
                            
                            setTimeout(() => {
                                this.render();
                                // Focus on new task
                                const newRow = container.querySelector(`[data-task-id="${newTaskId}"]`);
                                if (newRow) {
                                    newRow.classList.add('selected');
                                    newRow.focus();
                                    const titleInput = newRow.querySelector('.task-title');
                                    if (titleInput) {
                                        titleInput.focus();
                                        // Select all text for immediate editing
                                        const range = document.createRange();
                                        range.selectNodeContents(titleInput);
                                        const sel = window.getSelection();
                                        sel.removeAllRanges();
                                        sel.addRange(range);
                                    }
                                }
                            }, 50);
                            
                        } else if (e.key === 'Tab' && !e.shiftKey) {
                            // Move task down one level in hierarchy (indent)
                            // Find previous sibling to make this task its child
                            const parent = this.store.findParent(taskId);
                            const siblings = parent ? parent.children : this.store.tasks;
                            const currentIndex = siblings.findIndex(t => t.id === taskId);
                            
                            if (currentIndex > 0) {
                                // There's a previous sibling
                                const previousSibling = siblings[currentIndex - 1];
                                const task = siblings[currentIndex];
                                
                                // Remove from current parent
                                siblings.splice(currentIndex, 1);
                                
                                // Add as child of previous sibling
                                if (!previousSibling.children) {
                                    previousSibling.children = [];
                                }
                                previousSibling.children.push(task);
                                
                                // Expand previous sibling if collapsed
                                if (this.store.collapsed.has(previousSibling.id)) {
                                    this.store.collapsed.delete(previousSibling.id);
                                }
                                
                                this.store.saveState();
                                this.selectedTaskId = taskId; // Keep selection
                                
                                // Re-render and refocus
                                setTimeout(() => {
                                    this.render();
                                    const refocusRow = container.querySelector(`[data-task-id="${taskId}"]`);
                                    if (refocusRow) {
                                        refocusRow.focus();
                                        refocusRow.classList.add('selected');
                                    }
                                }, 0);
                            }
                            // If currentIndex is 0 or no previous sibling, just do nothing (already prevented default)
                            
                        } else if (e.key === 'Tab' && e.shiftKey) {
                            // Move task up one level in hierarchy (outdent)
                            const parent = this.store.findParent(taskId);
                            if (parent) {
                                const grandparent = this.store.findParent(parent.id);
                                const task = this.store.findTask(taskId);
                                
                                // Remove from current parent
                                const parentIndex = parent.children.findIndex(t => t.id === taskId);
                                if (parentIndex > -1) {
                                    parent.children.splice(parentIndex, 1);
                                }
                                
                                // Add to grandparent (or root if no grandparent)
                                if (grandparent) {
                                    // Find parent's index in grandparent and insert after it
                                    const parentIndexInGrandparent = grandparent.children.findIndex(t => t.id === parent.id);
                                    grandparent.children.splice(parentIndexInGrandparent + 1, 0, task);
                                } else {
                                    // Parent is at root level, so add to root after parent
                                    const parentIndexInRoot = this.store.tasks.findIndex(t => t.id === parent.id);
                                    this.store.tasks.splice(parentIndexInRoot + 1, 0, task);
                                }
                                
                                this.store.saveState();
                                this.selectedTaskId = taskId; // Keep selection
                                
                                // Re-render and refocus
                                setTimeout(() => {
                                    this.render();
                                    const refocusRow = container.querySelector(`[data-task-id="${taskId}"]`);
                                    if (refocusRow) {
                                        refocusRow.focus();
                                        refocusRow.classList.add('selected');
                                    }
                                }, 0);
                            }
                            // If no parent (already at root), just do nothing (already prevented default)
                            
                        } else if (e.key === 'Delete' || e.key === 'Backspace') {
                            e.preventDefault();
                            e.stopPropagation();
                            if (confirm(`Delete "${this.store.findTask(taskId).title}"?`)) {
                                this.store.deleteTask(taskId);
                                this.selectedTaskId = null;
                                this.render();
                            }
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            e.stopPropagation();
                            const allRows = Array.from(container.querySelectorAll('.task-row'));
                            const currentIndex = allRows.indexOf(row);
                            if (currentIndex < allRows.length - 1) {
                                allRows.forEach(r => r.classList.remove('selected'));
                                allRows[currentIndex + 1].classList.add('selected');
                                allRows[currentIndex + 1].focus();
                                this.selectedTaskId = allRows[currentIndex + 1].dataset.taskId;
                            }
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            e.stopPropagation();
                            const allRows = Array.from(container.querySelectorAll('.task-row'));
                            const currentIndex = allRows.indexOf(row);
                            if (currentIndex > 0) {
                                allRows.forEach(r => r.classList.remove('selected'));
                                allRows[currentIndex - 1].classList.add('selected');
                                allRows[currentIndex - 1].focus();
                                this.selectedTaskId = allRows[currentIndex - 1].dataset.taskId;
                            }
                        }
                    });

                    // Make row focusable for keyboard navigation
                    row.setAttribute('tabindex', '0');
                });

                // Click on status icon to open detail panel
                container.querySelectorAll('[data-task-click]').forEach(el => {
                    if (!el.classList.contains('task-title')) {
                        el.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const taskId = e.target.dataset.taskClick;
                            if (this.linkMode) {
                                this.handleLinkModeClick(taskId);
                            } else {
                                this.showDetailPanel(taskId);
                            }
                        });
                    }
                });

                // Description editing
                container.querySelectorAll('.task-description[contenteditable="true"]').forEach(descEl => {
                    const taskId = descEl.dataset.taskId;
                    
                    // Clear placeholder on focus
                    descEl.addEventListener('focus', (e) => {
                        if (descEl.classList.contains('task-placeholder')) {
                            descEl.textContent = '';
                            descEl.classList.remove('task-placeholder');
                        }
                    });

                    // Save on blur
                    descEl.addEventListener('blur', (e) => {
                        const newDesc = e.target.textContent.trim();
                        const originalDesc = e.target.dataset.originalDesc;
                        
                        if (newDesc !== originalDesc) {
                            this.store.updateTask(taskId, { description: newDesc });
                            e.target.dataset.originalDesc = newDesc;
                        }
                        
                        // Restore placeholder if empty
                        if (!newDesc) {
                            descEl.classList.add('task-placeholder');
                            descEl.textContent = 'Click to add description...';
                        }
                    });

                    // Prevent Enter from creating new lines, instead blur to save
                    descEl.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            descEl.blur();
                        }
                    });
                });
            }

            handleLinkModeClick(taskId) {
                if (!this.linkSource) {
                    this.linkSource = taskId;
                    const banner = document.getElementById('linkModeBanner');
                    banner.textContent = `üîó Source selected. Now click the task that depends on "${this.store.findTask(taskId).title}"`;
                } else {
                    if (this.linkSource !== taskId) {
                        this.store.addDependency(taskId, this.linkSource);
                        const banner = document.getElementById('linkModeBanner');
                        banner.textContent = `‚úì Dependency created! Click another task or toggle Link Mode off.`;
                    }
                    this.linkSource = null;
                }
            }

            renderKanban(container) {
                const statuses = ['todo', 'in-progress', 'review', 'done'];
                const statusNames = {
                    'todo': 'To Do',
                    'in-progress': 'In Progress',
                    'review': 'Review',
                    'done': 'Done'
                };

                // Get only leaf tasks (tasks with no children)
                const flatTasks = this.store.getFlatTasks();
                const leafTasks = flatTasks.filter(task => !task.children || task.children.length === 0);

                // Helper to get breadcrumb path
                const getPath = (taskId) => {
                    const path = [];
                    const findPath = (tasks, targetId, currentPath = []) => {
                        for (const task of tasks) {
                            const newPath = [...currentPath, task.title];
                            if (task.id === targetId) {
                                return newPath;
                            }
                            if (task.children) {
                                const result = findPath(task.children, targetId, newPath);
                                if (result) return result;
                            }
                        }
                        return null;
                    };
                    return findPath(this.store.tasks, taskId);
                };

                const columns = statuses.map(status => {
                    let tasks = leafTasks.filter(t => t.metadata.status === status);

                    // Sort by priority if enabled
                    if (this.store.sortByPriority) {
                        const priorityOrder = { high: 0, medium: 1, low: 2 };
                        tasks = tasks.sort((a, b) => {
                            const aPriority = priorityOrder[a.metadata.priority || 'medium'];
                            const bPriority = priorityOrder[b.metadata.priority || 'medium'];
                            return aPriority - bPriority;
                        });
                    }
                    
                    return `
                        <div class="kanban-column" data-status="${status}">
                            <div class="kanban-header">
                                <span>${statusNames[status]}</span>
                                <span class="badge">${tasks.length}</span>
                            </div>
                            <div class="kanban-cards">
                                ${tasks.map(task => {
                                    const path = getPath(task.id);
                                    const breadcrumb = path.slice(0, -1).join(' ‚Ä∫ ');
                                    const dependencies = this.store.getDependencies(task.id);
                                    
                                    return `
                                        <div class="kanban-card" draggable="true" data-task-id="${task.id}">
                                            ${breadcrumb ? `<div class="kanban-card-path">${breadcrumb}</div>` : ''}
                                            <div class="kanban-card-title">${task.title}</div>
                                            ${task.description ? `<div style="font-size: 12px; color: #666; margin-top: 4px;">${task.description}</div>` : ''}
                                            <div class="kanban-card-meta">
                                                ${task.metadata.assignee ? `<span class="assignee">${task.metadata.assignee}</span>` : ''}
                                                ${task.metadata.priority === 'high' ? '<span class="priority-indicator" title="High Priority">‚ö†Ô∏è</span>' : ''}
                                                ${dependencies.length > 0 ? `<span class="dependency-badge">‚Üí ${dependencies.length}</span>` : ''}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = `<div class="kanban-view">${columns}</div>`;

                // Drag and drop
                const cards = container.querySelectorAll('.kanban-card');
                const columnElements = container.querySelectorAll('.kanban-column');

                cards.forEach(card => {
                    card.addEventListener('dragstart', (e) => {
                        card.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', card.innerHTML);
                    });

                    card.addEventListener('dragend', () => {
                        card.classList.remove('dragging');
                    });

                    card.addEventListener('click', () => {
                        const taskId = card.dataset.taskId;
                        if (this.linkMode) {
                            this.handleLinkModeClick(taskId);
                        } else {
                            this.showDetailPanel(taskId);
                        }
                    });
                });

                columnElements.forEach(column => {
                    column.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        const dragging = document.querySelector('.dragging');
                        const afterElement = this.getDragAfterElement(column, e.clientY);
                        const cardsContainer = column.querySelector('.kanban-cards');
                        
                        if (afterElement == null) {
                            cardsContainer.appendChild(dragging);
                        } else {
                            cardsContainer.insertBefore(dragging, afterElement);
                        }
                    });

                    column.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const card = document.querySelector('.dragging');
                        const taskId = card.dataset.taskId;
                        const newStatus = column.dataset.status;
                        
                        this.store.updateTask(taskId, { 'metadata.status': newStatus });
                    });
                });
            }

            getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.kanban-card:not(.dragging)')];

                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;

                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            renderGantt(container) {
                const tasksWithDates = this.store.tasks.filter(t => t.metadata.startDate && t.metadata.endDate);
                
                if (tasksWithDates.length === 0) {
                    container.innerHTML = '<div style="padding: 40px; text-align: center; color: #999;">No tasks with dates to display. Add start and end dates to tasks.</div>';
                    return;
                }

                // Get all tasks with dates (including nested)
                const getAllTasksWithDates = (tasks) => {
                    let result = [];
                    tasks.forEach(task => {
                        if (task.metadata.startDate && task.metadata.endDate) {
                            result.push(task);
                        }
                        if (task.children && task.children.length > 0) {
                            result = result.concat(getAllTasksWithDates(task.children));
                        }
                    });
                    return result;
                };

                const allTasks = getAllTasksWithDates(this.store.tasks);
                const zoomLevel = this.ganttZoom || 'months';
                
                // Calculate date range
                const allDates = allTasks.flatMap(t => [new Date(t.metadata.startDate), new Date(t.metadata.endDate)]);
                const minDate = new Date(Math.min(...allDates));
                const maxDate = new Date(Math.max(...allDates));

                // Generate time periods based on zoom
                let periods = [];
                let cellWidth = 80;
                
                if (zoomLevel === 'quarters') {
                    const startQ = Math.floor(minDate.getMonth() / 3);
                    const endQ = Math.floor(maxDate.getMonth() / 3);
                    const startYear = minDate.getFullYear();
                    const endYear = maxDate.getFullYear();
                    
                    for (let y = startYear; y <= endYear; y++) {
                        const start = (y === startYear) ? startQ : 0;
                        const end = (y === endYear) ? endQ : 3;
                        for (let q = start; q <= end; q++) {
                            periods.push({
                                label: `Q${q + 1} ${y}`,
                                start: new Date(y, q * 3, 1),
                                end: new Date(y, (q + 1) * 3, 0)
                            });
                        }
                    }
                } else if (zoomLevel === 'months') {
                    let current = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
                    const end = new Date(maxDate.getFullYear(), maxDate.getMonth() + 1, 0);
                    
                    while (current <= end) {
                        const monthEnd = new Date(current.getFullYear(), current.getMonth() + 1, 0);
                        periods.push({
                            label: current.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }),
                            start: new Date(current),
                            end: monthEnd
                        });
                        current = new Date(current.getFullYear(), current.getMonth() + 1, 1);
                    }
                } else if (zoomLevel === 'weeks') {
                    cellWidth = 60;
                    let current = new Date(minDate);
                    current.setDate(current.getDate() - current.getDay()); // Start of week
                    
                    while (current <= maxDate) {
                        const weekEnd = new Date(current);
                        weekEnd.setDate(weekEnd.getDate() + 6);
                        periods.push({
                            label: `${current.getMonth() + 1}/${current.getDate()}`,
                            start: new Date(current),
                            end: weekEnd
                        });
                        current.setDate(current.getDate() + 7);
                    }
                } else { // days
                    cellWidth = 40;
                    let current = new Date(minDate);
                    
                    while (current <= maxDate) {
                        periods.push({
                            label: `${current.getMonth() + 1}/${current.getDate()}`,
                            start: new Date(current),
                            end: new Date(current)
                        });
                        current.setDate(current.getDate() + 1);
                    }
                }

                const timelineWidth = periods.length * cellWidth;

                // Initialize ganttCollapsed set if it doesn't exist
                if (!this.store.ganttCollapsed) {
                    this.store.ganttCollapsed = new Set();
                }

                // Render tasks hierarchically with collapse
                const renderTaskRows = (tasks, depth = 0) => {
                    let rows = [];

                    tasks.forEach(task => {
                        // Only show tasks that have dates
                        if (!task.metadata.startDate || !task.metadata.endDate) return;

                        const hasChildren = task.children && task.children.some(c => c.metadata.startDate && c.metadata.endDate);
                        const isCollapsed = this.store.ganttCollapsed.has(task.id);

                        rows.push({
                            task,
                            depth,
                            hasChildren,
                            isCollapsed
                        });
                        
                        // Recursively add children if not collapsed
                        if (hasChildren && !isCollapsed) {
                            rows = rows.concat(renderTaskRows(task.children, depth + 1));
                        }
                    });
                    
                    return rows;
                };

                const taskRows = renderTaskRows(this.store.tasks);

                container.innerHTML = `
                    <div class="gantt-view">
                        <div class="gantt-controls">
                            <button class="gantt-zoom-btn ${zoomLevel === 'quarters' ? 'active' : ''}" data-zoom="quarters">Quarters</button>
                            <button class="gantt-zoom-btn ${zoomLevel === 'months' ? 'active' : ''}" data-zoom="months">Months</button>
                            <button class="gantt-zoom-btn ${zoomLevel === 'weeks' ? 'active' : ''}" data-zoom="weeks">Weeks</button>
                            <button class="gantt-zoom-btn ${zoomLevel === 'days' ? 'active' : ''}" data-zoom="days">Days</button>
                        </div>
                        <div class="gantt-container">
                            <div class="gantt-grid">
                                <div class="gantt-tasks">
                                    <div class="gantt-header">Tasks</div>
                                    ${taskRows.map(row => `
                                        <div class="gantt-task-row" data-task-id="${row.task.id}">
                                            <div class="gantt-task-title" style="padding-left: ${row.depth * 20}px">
                                                ${row.hasChildren ?
                                                    `<button class="collapse-btn" data-gantt-collapse="${row.task.id}" style="margin-right: 4px;">${row.isCollapsed ? '‚ñ∂' : '‚ñº'}</button>` :
                                                    '<span style="display: inline-block; width: 24px;"></span>'
                                                }
                                                ${this.store.showPriorityInGantt && row.task.metadata.priority === 'high' ? '<span class="priority-indicator" title="High Priority">‚ö†Ô∏è</span>' : ''}
                                                ${row.task.title}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="gantt-timeline" style="min-width: ${timelineWidth}px">
                                    <div class="gantt-timeline-header">
                                        ${periods.map(p => `
                                            <div class="gantt-time-cell" style="min-width: ${cellWidth}px">${p.label}</div>
                                        `).join('')}
                                    </div>
                                    ${taskRows.map(row => {
                                        const task = row.task;
                                        const taskStart = new Date(task.metadata.startDate);
                                        const taskEnd = new Date(task.metadata.endDate);
                                        
                                        let startCell = 0;
                                        let span = 0;
                                        
                                        periods.forEach((period, idx) => {
                                            if (taskStart <= period.end && taskEnd >= period.start) {
                                                if (span === 0) startCell = idx;
                                                span++;
                                            }
                                        });
                                        
                                        const left = startCell * cellWidth;
                                        const width = Math.max(span * cellWidth - 4, 40);
                                        
                                        // Status colors
                                        const statusColors = {
                                            'todo': '#94a3b8',
                                            'in-progress': '#3b82f6',
                                            'review': '#f59e0b',
                                            'done': '#10b981'
                                        };
                                        const barColor = statusColors[task.metadata.status] || '#3b82f6';
                                        
                                        return `
                                            <div class="gantt-bar-row">
                                                ${periods.map((p, idx) => `
                                                    <div class="gantt-bar-cell" style="min-width: ${cellWidth}px">
                                                        ${idx === startCell ? `
                                                            <div class="gantt-bar" style="left: 2px; width: ${width}px; justify-content: center; text-align: center; background: ${barColor};" data-task-id="${task.id}">
                                                                ${task.title}
                                                            </div>
                                                        ` : ''}
                                                    </div>
                                                `).join('')}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;

                // Collapse/expand buttons
                container.querySelectorAll('[data-gantt-collapse]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const taskId = btn.dataset.ganttCollapse;
                        if (this.store.ganttCollapsed.has(taskId)) {
                            this.store.ganttCollapsed.delete(taskId);
                        } else {
                            this.store.ganttCollapsed.add(taskId);
                        }
                        this.render();
                    });
                });

                // Zoom controls
                container.querySelectorAll('[data-zoom]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.ganttZoom = e.target.dataset.zoom;
                        this.render();
                    });
                });

                // Task clicks
                container.querySelectorAll('[data-task-id]').forEach(el => {
                    el.addEventListener('click', () => {
                        const taskId = el.dataset.taskId;
                        if (this.linkMode) {
                            this.handleLinkModeClick(taskId);
                        } else {
                            this.showDetailPanel(taskId);
                        }
                    });
                });
            }

            renderMindMap(container) {
                if (this.store.tasks.length === 0) {
                    container.innerHTML = '<div style="padding: 40px; text-align: center; color: #999;">No tasks to display</div>';
                    return;
                }

                // Use first root task as center
                const rootTask = this.store.tasks[0];
                
                // Initialize mode if not set
                if (!this.mindmapMode) {
                    this.mindmapMode = 'tree'; // Default to tree mode
                }

                // Initialize collapsed nodes set
                if (!this.mindmapCollapsed) {
                    this.mindmapCollapsed = new Set();
                }

                container.innerHTML = `
                    <div class="mindmap-view">
                        <div class="mindmap-controls">
                            <!-- Mode toggle moved to settings pane -->
                            <button class="mindmap-btn" id="zoomIn">+ Zoom In</button>
                            <button class="mindmap-btn" id="zoomOut">‚àí Zoom Out</button>
                            <button class="mindmap-btn" id="resetView">‚ü≤ Reset</button>
                        </div>
                        <div class="mindmap-content" id="mindmapContent">
                            <div class="mindmap-canvas" id="mindmapCanvas">
                                <svg class="mindmap-svg" id="mindmapSvg" style="position: absolute; top: 0; left: 0; width: 3000px; height: 3000px; z-index: 1;"></svg>
                                <div id="mindmapNodes" style="position: absolute; top: 0; left: 0; width: 3000px; height: 3000px; z-index: 2;"></div>
                            </div>
                        </div>
                    </div>
                `;

                const content = container.querySelector('#mindmapContent');
                const canvas = container.querySelector('#mindmapCanvas');
                const svg = container.querySelector('#mindmapSvg');
                const nodesContainer = container.querySelector('#mindmapNodes');

                // Fixed canvas size - large enough for all nodes
                const canvasSize = 3000;
                const centerX = canvasSize / 2;
                const centerY = canvasSize / 2;

                const nodes = [];
                const lines = [];

                if (this.mindmapMode === 'tree') {
                    // TREE LAYOUT - Top-down hierarchical
                    const startY = 200;
                    const levelHeight = 180;
                    const horizontalSpacing = 200;

                    // Calculate width needed for each subtree
                    const calculateWidth = (task) => {
                        if (!task.children || task.children.length === 0 || this.mindmapCollapsed.has(task.id)) {
                            return horizontalSpacing;
                        }
                        const childrenWidth = task.children.reduce((sum, child) =>
                            sum + calculateWidth(child), 0);
                        return Math.max(childrenWidth, horizontalSpacing);
                    };

                    // Place nodes recursively in tree layout
                    const placeTreeNodes = (task, x, y, level) => {
                        // Add node at position
                        nodes.push({ task, x, y, level });

                        // Only show children if not collapsed
                        if (task.children && task.children.length > 0 && !this.mindmapCollapsed.has(task.id)) {
                            const childWidths = task.children.map(calculateWidth);
                            const totalWidth = childWidths.reduce((a, b) => a + b, 0);

                            let currentX = x - totalWidth / 2;

                            task.children.forEach((child, idx) => {
                                const childWidth = childWidths[idx];
                                const childX = currentX + childWidth / 2;
                                const childY = y + levelHeight;

                                // Draw line from parent to child
                                lines.push({
                                    x1: x,
                                    y1: y + 40,  // Bottom of parent node
                                    x2: childX,
                                    y2: childY   // Top of child node
                                });

                                placeTreeNodes(child, childX, childY, level + 1);
                                currentX += childWidth;
                            });
                        }
                    };

                    placeTreeNodes(rootTask, centerX, startY, 0);

                } else {
                    // RADIAL LAYOUT - Circular spread
                    // Place root at center
                    nodes.push({
                        task: rootTask,
                        x: centerX,
                        y: centerY,
                        level: 0
                    });

                    // Recursively place children in a radial pattern
                    const placeChildren = (parent, parentX, parentY, level, startAngle, angleSpan) => {
                        if (!parent.children || parent.children.length === 0 || this.mindmapCollapsed.has(parent.id)) return;

                        const radius = 200 + (level * 150);
                        const angleStep = angleSpan / Math.max(parent.children.length, 1);

                        parent.children.forEach((child, idx) => {
                            const angle = startAngle + (angleStep * idx) + (angleStep / 2);
                            const x = parentX + Math.cos(angle) * radius;
                            const y = parentY + Math.sin(angle) * radius;

                            nodes.push({
                                task: child,
                                x,
                                y,
                                level
                            });

                            // Connect from parent center to child center
                            // Nodes are 160px wide and ~40px tall, so center is at x, y+20
                            lines.push({
                                x1: parentX,
                                y1: parentY + 20,
                                x2: x,
                                y2: y + 20
                            });

                            // Recursively place this child's children
                            placeChildren(child, x, y, level + 1, angle - angleStep / 2, angleStep);
                        });
                    };

                    placeChildren(rootTask, centerX, centerY, 1, 0, Math.PI * 2);
                }

                // Draw lines using PIXEL coordinates (no viewBox!)
                svg.innerHTML = lines.map(line => `
                    <line x1="${line.x1}" y1="${line.y1}" 
                          x2="${line.x2}" y2="${line.y2}"
                          stroke="#334155"
                          stroke-width="3"
                          vector-effect="non-scaling-stroke"
                          fill="none" />
                `).join('');

                // Draw nodes using SAME pixel coordinates
                nodesContainer.innerHTML = nodes.map(node => {
                    const hasChildren = node.task.children && node.task.children.length > 0;
                    const isCollapsed = this.mindmapCollapsed.has(node.task.id);
                    return `
                    <div class="mindmap-node ${node.level === 0 ? 'root' : `level-${Math.min(node.level, 3)}`}"
                         style="position: absolute; left: ${node.x - 80}px; top: ${node.y - 20}px; width: 160px;"
                         data-task-id="${node.task.id}">
                        ${hasChildren ? `
                            <div class="mindmap-collapse-container" style="position: absolute; top: -8px; right: -8px; display: flex; flex-direction: column; gap: 2px;">
                                <button class="mindmap-collapse-btn-one"
                                        data-task-id="${node.task.id}"
                                        data-action="${isCollapsed ? 'expand-one' : 'collapse-one'}"
                                        title="${isCollapsed ? 'Expand 1 Level' : 'Collapse 1 Level'}"
                                        style="width: 20px; height: 20px; border-radius: 50%; border: 2px solid #3b82f6; background: white; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; font-weight: bold; color: #3b82f6; padding: 0; line-height: 1;">
                                    ${isCollapsed ? '+' : '‚àí'}
                                </button>
                                <button class="mindmap-collapse-btn-all"
                                        data-task-id="${node.task.id}"
                                        data-action="${isCollapsed ? 'expand-all' : 'collapse-all'}"
                                        title="${isCollapsed ? 'Expand All Descendants' : 'Collapse All Descendants'}"
                                        style="width: 20px; height: 20px; border-radius: 50%; border: 2px solid #10b981; background: white; cursor: pointer; font-size: 11px; display: flex; align-items: center; justify-content: center; font-weight: bold; color: #10b981; padding: 0; line-height: 1;">
                                    ${isCollapsed ? '‚äï' : '‚äñ'}
                                </button>
                            </div>
                        ` : ''}
                        <div style="padding-right: ${hasChildren ? '20px' : '0'};">
                            ${node.task.title}
                        </div>
                        <div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">
                            ${node.task.metadata.assignee || ''}
                            ${node.task.metadata.priority === 'high' ? '<span class="priority-indicator" title="High Priority" style="margin-left: 4px;">‚ö†Ô∏è</span>' : ''}
                        </div>
                    </div>
                `;
                }).join('');

                // Pan and zoom functionality
                // Restore previous state if it exists, otherwise use defaults
                const state = {
                    offsetX: this.mindmapPanX !== undefined ? this.mindmapPanX : -(canvasSize / 2 - content.offsetWidth / 2),
                    offsetY: this.mindmapPanY !== undefined ? this.mindmapPanY : (this.mindmapMode === 'tree'
                        ? 50  // Tree mode: start near top
                        : -(canvasSize / 2 - content.offsetHeight / 2)), // Radial mode: center
                    scale: this.mindmapScale !== undefined ? this.mindmapScale : 1,
                    isDragging: false,
                    startX: 0,
                    startY: 0
                };

                // Apply initial centering
                canvas.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px) scale(${state.scale})`;
                // Use default transform origin (0, 0) for simpler zoom math
                canvas.style.transformOrigin = '0 0';

                const updateTransform = () => {
                    // Use requestAnimationFrame to ensure smooth rendering
                    requestAnimationFrame(() => {
                        // Calculate the center point in screen space
                        const viewportCenterX = content.offsetWidth / 2;
                        const viewportCenterY = content.offsetHeight / 2;
                        
                        // The root node is at canvasSize/2, canvasSize/2 in canvas coordinates
                        // We want to keep it centered in the viewport while zooming
                        const rootInScreenX = (canvasSize / 2) * state.scale + state.offsetX;
                        const rootInScreenY = (canvasSize / 2) * state.scale + state.offsetY;
                        
                        canvas.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px) scale(${state.scale})`;
                        
                        // Adjust stroke width inversely to scale to keep lines crisp
                        const adjustedStrokeWidth = 3 / state.scale;
                        svg.querySelectorAll('line').forEach(line => {
                            line.setAttribute('stroke-width', adjustedStrokeWidth);
                        });
                    });
                };

                content.addEventListener('mousedown', (e) => {
                    // Allow dragging on background, canvas, svg, or lines
                    const target = e.target;
                    const isBackground = target === content || 
                                        target === canvas || 
                                        target.id === 'mindmapCanvas' ||
                                        target.id === 'mindmapSvg' ||
                                        target.id === 'mindmapNodes' ||
                                        target.tagName === 'svg' || 
                                        target.tagName === 'line';
                    
                    if (isBackground) {
                        e.preventDefault();
                        state.isDragging = true;
                        state.startX = e.clientX - state.offsetX;
                        state.startY = e.clientY - state.offsetY;
                        content.style.cursor = 'grabbing';
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (state.isDragging) {
                        e.preventDefault();
                        state.offsetX = e.clientX - state.startX;
                        state.offsetY = e.clientY - state.startY;
                        updateTransform();
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (state.isDragging) {
                        state.isDragging = false;
                        content.style.cursor = 'grab';
                        // Save state for next render
                        this.mindmapPanX = state.offsetX;
                        this.mindmapPanY = state.offsetY;
                        this.mindmapScale = state.scale;
                    }
                });

                container.querySelector('#zoomIn').addEventListener('click', () => {
                    const oldScale = state.scale;
                    state.scale = Math.min(state.scale * 1.2, 3);

                    // Get viewport center
                    const viewportCenterX = content.offsetWidth / 2;
                    const viewportCenterY = content.offsetHeight / 2;

                    // Find the canvas point currently at viewport center
                    const canvasPointX = (viewportCenterX - state.offsetX) / oldScale;
                    const canvasPointY = (viewportCenterY - state.offsetY) / oldScale;

                    // After zoom, keep that same canvas point at viewport center
                    state.offsetX = viewportCenterX - canvasPointX * state.scale;
                    state.offsetY = viewportCenterY - canvasPointY * state.scale;

                    // Save state for next render
                    this.mindmapPanX = state.offsetX;
                    this.mindmapPanY = state.offsetY;
                    this.mindmapScale = state.scale;

                    updateTransform();
                });

                container.querySelector('#zoomOut').addEventListener('click', () => {
                    const oldScale = state.scale;
                    state.scale = Math.max(state.scale / 1.2, 0.3);

                    // Get viewport center
                    const viewportCenterX = content.offsetWidth / 2;
                    const viewportCenterY = content.offsetHeight / 2;

                    // Find the canvas point currently at viewport center
                    const canvasPointX = (viewportCenterX - state.offsetX) / oldScale;
                    const canvasPointY = (viewportCenterY - state.offsetY) / oldScale;

                    // After zoom, keep that same canvas point at viewport center
                    state.offsetX = viewportCenterX - canvasPointX * state.scale;
                    state.offsetY = viewportCenterY - canvasPointY * state.scale;

                    // Save state for next render
                    this.mindmapPanX = state.offsetX;
                    this.mindmapPanY = state.offsetY;
                    this.mindmapScale = state.scale;

                    updateTransform();
                });

                container.querySelector('#resetView').addEventListener('click', () => {
                    state.offsetX = -(canvasSize / 2 - content.offsetWidth / 2);
                    state.offsetY = this.mindmapMode === 'tree'
                        ? 50
                        : -(canvasSize / 2 - content.offsetHeight / 2);
                    state.scale = 1;

                    // Save state for next render
                    this.mindmapPanX = state.offsetX;
                    this.mindmapPanY = state.offsetY;
                    this.mindmapScale = state.scale;

                    updateTransform();
                });

                // Mode change listener now handled in settings pane

                // Set initial cursor
                content.style.cursor = 'grab';

                // Helper function to get all descendant IDs
                const getAllDescendantIds = (task) => {
                    const ids = [];
                    const traverse = (t) => {
                        if (t.children && t.children.length > 0) {
                            t.children.forEach(child => {
                                ids.push(child.id);
                                traverse(child);
                            });
                        }
                    };
                    traverse(task);
                    return ids;
                };

                // Collapse/expand button clicks (both one-level and all)
                const handleCollapseClick = (btn) => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent triggering node click
                        const taskId = btn.dataset.taskId;
                        const action = btn.dataset.action;
                        const task = this.store.findTask(taskId);

                        if (!task) return;

                        switch(action) {
                            case 'collapse-one':
                                this.mindmapCollapsed.add(taskId);
                                break;
                            case 'expand-one':
                                this.mindmapCollapsed.delete(taskId);
                                break;
                            case 'collapse-all':
                                // Collapse this node and all descendants
                                this.mindmapCollapsed.add(taskId);
                                const descendantIds = getAllDescendantIds(task);
                                descendantIds.forEach(id => this.mindmapCollapsed.add(id));
                                break;
                            case 'expand-all':
                                // Expand this node and all descendants
                                this.mindmapCollapsed.delete(taskId);
                                const allDescendantIds = getAllDescendantIds(task);
                                allDescendantIds.forEach(id => this.mindmapCollapsed.delete(id));
                                break;
                        }

                        this.render();
                    });
                };

                // Add listeners to both button types
                container.querySelectorAll('.mindmap-collapse-btn-one').forEach(btn => handleCollapseClick(btn));
                container.querySelectorAll('.mindmap-collapse-btn-all').forEach(btn => handleCollapseClick(btn));

                // Node clicks
                container.querySelectorAll('.mindmap-node').forEach(node => {
                    node.addEventListener('click', (e) => {
                        // Ignore clicks on collapse buttons
                        if (e.target.classList.contains('mindmap-collapse-btn-one') ||
                            e.target.classList.contains('mindmap-collapse-btn-all') ||
                            e.target.closest('.mindmap-collapse-container')) {
                            return;
                        }
                        e.stopPropagation();
                        const taskId = e.target.closest('.mindmap-node').dataset.taskId;
                        if (this.linkMode) {
                            this.handleLinkModeClick(taskId);
                        } else {
                            this.showNodeModal(taskId);
                        }
                    });
                });
            }

            showNodeModal(taskId) {
                const task = this.store.findTask(taskId);
                if (!task) return;

                const modal = document.getElementById('nodeModal');
                const content = document.getElementById('nodeModalContent');

                const childrenHtml = task.children && task.children.length > 0 ? `
                    <div class="detail-field">
                        <div class="detail-label">Subtasks (${task.children.length})</div>
                        <div style="padding-left: 12px;">
                            ${task.children.map(child => `
                                <div style="padding: 4px 0; display: flex; align-items: center; gap: 8px;">
                                    <div class="status-icon status-${child.metadata.status}" style="width: 16px; height: 16px; font-size: 10px;">
                                        ${child.metadata.status === 'done' ? '‚úì' : 
                                          child.metadata.status === 'in-progress' ? '‚ö°' : '‚óã'}
                                    </div>
                                    <span>${child.title}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                ` : '';

                content.innerHTML = `
                    <div class="modal-header">${task.title}</div>
                    
                    ${task.description ? `
                        <div class="detail-field">
                            <div class="detail-label">Description</div>
                            <p>${task.description}</p>
                        </div>
                    ` : ''}

                    <div class="detail-field">
                        <div class="detail-label">Status</div>
                        <span class="badge badge-${task.metadata.status}">${task.metadata.status}</span>
                    </div>

                    ${task.metadata.assignee ? `
                        <div class="detail-field">
                            <div class="detail-label">Assignee</div>
                            <span>${task.metadata.assignee}</span>
                        </div>
                    ` : ''}

                    ${childrenHtml}

                    <div class="detail-actions">
                        <button class="btn btn-primary" id="editTaskFromModal">Edit Details</button>
                        <button class="btn btn-secondary" id="closeNodeModal">Close</button>
                    </div>
                `;

                modal.classList.add('visible');

                content.querySelector('#editTaskFromModal').addEventListener('click', () => {
                    modal.classList.remove('visible');
                    this.showDetailPanel(taskId);
                });

                content.querySelector('#closeNodeModal').addEventListener('click', () => {
                    modal.classList.remove('visible');
                });
            }

            showDetailPanel(taskId) {
                const task = this.store.findTask(taskId);
                if (!task) return;

                this.selectedTask = taskId;
                const panel = document.getElementById('detailPanel');
                const dependencies = this.store.getDependencies(taskId);
                
                // Get list of all tasks for dependency selection
                const allTasks = this.store.getFlatTasks().filter(t => t.id !== taskId);
                
                panel.innerHTML = `
                    <div class="detail-header">Task Details</div>
                    
                    <div class="detail-field">
                        <div class="detail-label">Title</div>
                        <input type="text" class="detail-input" id="taskTitle" value="${task.title}">
                    </div>

                    <div class="detail-field">
                        <div class="detail-label">Description</div>
                        <textarea class="detail-input detail-textarea" id="taskDescription">${task.description || ''}</textarea>
                    </div>

                    <div class="detail-field">
                        <div class="detail-label">Status</div>
                        <select class="detail-select" id="taskStatus">
                            <option value="todo" ${task.metadata.status === 'todo' ? 'selected' : ''}>To Do</option>
                            <option value="in-progress" ${task.metadata.status === 'in-progress' ? 'selected' : ''}>In Progress</option>
                            <option value="review" ${task.metadata.status === 'review' ? 'selected' : ''}>Review</option>
                            <option value="done" ${task.metadata.status === 'done' ? 'selected' : ''}>Done</option>
                        </select>
                    </div>

                    <div class="detail-field">
                        <div class="detail-label">Priority</div>
                        <select class="detail-select" id="taskPriority">
                            <option value="low" ${task.metadata.priority === 'low' ? 'selected' : ''}>Low</option>
                            <option value="medium" ${task.metadata.priority === 'medium' ? 'selected' : ''}>Medium</option>
                            <option value="high" ${task.metadata.priority === 'high' ? 'selected' : ''}>High</option>
                        </select>
                    </div>

                    <div class="detail-field">
                        <div class="detail-label">Assignee</div>
                        <input type="text" class="detail-input" id="taskAssignee" value="${task.metadata.assignee || ''}">
                    </div>

                    <div class="detail-field">
                        <div class="detail-label">Start Date</div>
                        <input type="date" class="detail-input" id="taskStartDate" value="${task.metadata.startDate || ''}">
                    </div>

                    <div class="detail-field">
                        <div class="detail-label">End Date</div>
                        <input type="date" class="detail-input" id="taskEndDate" value="${task.metadata.endDate || ''}">
                    </div>

                    <div class="detail-field">
                        <div class="detail-label">Dependencies (this task depends on:)</div>
                        <select class="detail-select" id="addDependency">
                            <option value="">+ Add dependency...</option>
                            ${allTasks.map(t => `<option value="${t.id}">${t.title}</option>`).join('')}
                        </select>
                        ${dependencies.length > 0 ? `
                            <div class="dependency-list">
                                ${dependencies.map(depId => {
                                    const depTask = this.store.findTask(depId);
                                    return depTask ? `
                                        <div class="dependency-item">
                                            <span>‚Üí ${depTask.title}</span>
                                            <span class="remove-dep" data-remove-dep="${depId}">√ó</span>
                                        </div>
                                    ` : '';
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>

                    <div class="detail-actions">
                        <button class="btn btn-primary" id="saveTask">Save</button>
                        <button class="btn btn-secondary" id="closePanel">Close</button>
                    </div>
                `;

                panel.classList.add('visible');

                // Add dependency dropdown
                panel.querySelector('#addDependency').addEventListener('change', (e) => {
                    if (e.target.value) {
                        this.store.addDependency(taskId, e.target.value);
                        e.target.value = '';
                        this.showDetailPanel(taskId); // Refresh
                    }
                });

                // Remove dependency buttons
                panel.querySelectorAll('[data-remove-dep]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.store.removeDependency(taskId, e.target.dataset.removeDep);
                        this.showDetailPanel(taskId); // Refresh
                    });
                });

                // Save button
                panel.querySelector('#saveTask').addEventListener('click', () => {
                    this.store.updateTask(taskId, {
                        title: panel.querySelector('#taskTitle').value,
                        description: panel.querySelector('#taskDescription').value,
                        'metadata.status': panel.querySelector('#taskStatus').value,
                        'metadata.priority': panel.querySelector('#taskPriority').value,
                        'metadata.assignee': panel.querySelector('#taskAssignee').value,
                        'metadata.startDate': panel.querySelector('#taskStartDate').value,
                        'metadata.endDate': panel.querySelector('#taskEndDate').value
                    });
                    panel.classList.remove('visible');
                });

                // Close button
                panel.querySelector('#closePanel').addEventListener('click', () => {
                    panel.classList.remove('visible');
                });
            }
        }

        // Initialize app
        const app = new App();
    </script>
</body>
</html>
